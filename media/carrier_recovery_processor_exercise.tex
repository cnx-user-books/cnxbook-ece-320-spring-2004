
%
%
% Module: carrier_recovery_processor_exercise
%
% Author: Michael Kramer
%
%

\paragraph{Sine Table Interpolation:}

Because
we must be able to finely adjust the oscillating (carrier) frequency,
some form of interpolation is required to generate our
demodulating sine and cosine using table look-up.
With the following sine table in memory: $\sin(\frac{2\pi}{N}k)$
for $k=0, ..., N-1$, we can generate a sine wave by incrementing
through the table.  If we skip through the table by $p$ samples
then we would generate a sine wave with a digital frequency of
$\lambda = \frac{2 \pi}{N} p$. 
In contrast to this method where the carrier
wave is generated by stepping through the sine
table by integral amounts, the demodulating sinusoids
in this exercise will be generated
using a mixed integer / fractional index.
This enables much more precise frequency adjustment of the demodulating
carrier. 


Typically one would use an address register and increment it by
an appropriate amount to generate the desired frequencies.  For
non-integral increments through the sine table a non-integral
``pointer'' must be used.  This pointer can interpreted as the phase
of equation (\ref{eq: phase_update}). To generate a sine sample indexed
by a non-integral pointer we can simply round the value
down to the nearest integer and then use it as a regular integer
pointer to our sine-table. 
Although this method of interpolation (also referred to
as a zero-order hold interpolator) is rather crude, for a
long enough sine table this approximation is good enough to 
finely adjust the NCO frequency for this application. 

To implement a non-integral pointer we can perform addition
in the accumulator with a modified decimal point.  For
example, with $N=256$ we need 8 bits to represent the
integer portion of our pointer.  If we interpret the 
lower 16 bits of the accumulator
to have a decimal point seven bits up
from the bottom, then there are still nine bits of space for 
an integer above this decimal point.
To step through the sine table we
can then add a 15-bit value to the low-part of the
accumulator, then mask off the top bit to ensure that
the value in the accumulator is between $0$ and $255.99999$
(this is similar to the modulo addition of $2 \pi$ discussed
in the \matlab Simulation section:  Why?)
To use only the integer portion of the ``pointer'' we
can shift the accumulator down by seven bits, then store
the low part into an address register, \verb+ARX+.  After adding the
start of the sine table to the \verb+ARX+ register we are now 
ready to look-up the approximating sample out of the sine table.
 
As an example, if we want the carrier frequency to be
$\lambda = \frac{\pi}{8}$, the integer step size 
would be $p=\frac{N}{16} = 8$.  When the decimal
place is interpreted as being 7 bits up from the 
bottom of the register, the corresponding value
to increment by would be $8 \times 2^7 = 1024$. 
(What would the output frequency be if this step size was
set to 1025?)
